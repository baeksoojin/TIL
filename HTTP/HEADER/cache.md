# Cache

## cache가 없다면?

캐시가 없다면 서버에서 동일한 요청이 들어와도 일련의 과정을 반복하여 데이터를 다운받게 되고 네트워크 사용이 커져서 느려진다.<br>

cache-control: max-age=60 등 과 같이 최대시간을 brwoser의 캐시에 저장하고 이를 활용하여 server에서 재실행하지 않고 네트워크를 사용하지 않아서 네트워크 사용량을 줄이고 속도를 높인다.<br>

다만, 캐시 시간이 초과된 경우에는 당연히 다시 요청해야한다.<br>

- 캐시 시간 초과

서버를 통해서 데이터를 다시 조회하고 캐시를 갱신해야하는데 이때는 다시 네트워크 다우닝 발생한다.<br>
다만, 주고 받는 데이터가 이전 캐시의 데이터와 동일한 경우라면 이렇게 하면 "낭비"가 될 것이다. 어떻게 해결할 수 있을까?

------


## 검증 헤더와 조건부 요청

- 캐시 시간 초과

    서버에서 기존 데이터를 변경하지 않는 경우라면 다시 다운로드 받아야할까?에 대한 의문이 생길 수 있다.<br>

    다시 다운받기 싫다면 바뀌지 않았다는 것을 알아야하는데 이때, 검증헤더를 사용한다.<br>

#### 검증 헤더 추가  : solution

1. Last-Modified<br>
2020년 11월 10일 처럼 서버에서 브라우저로 전송할 때 헤더에 포함해서 보내고 이것은 캐시에 저장된다.<br>
만료기간 이후에 `if-Modified-since` : 2020년 11월 10일 을 서버로 보내고 서버에서 데이터 최종 수정일을 보고 같다면 최종 수정이 되지 않을 경우임을 인지할 수 있다.<br>
**304 Not Modified : 캐시로 redirection**를 보내며 전송할 데이터가 없기 때문에 HTTP Body의 내용이 존재하지 않고 캐시가 바뀌지 않아서 그냥 그대로 사용하면 된다는 것으로 확인하면 된다.<br>

    따라서 결과적으로 네트워크 다운로드가 발생하지 않고 용량이 적은 헤더 정보만 다운받게 된다.<br>
    다만, 1초 미만 단위로 캐시 조정이 불가능하다. 날짜 기반의 정해진 로직을 사용해야한다.날짜는 다른데 데이터가 결국 똑같은 경우가 있을 수 있는데 이를 판단하지 못한다.<br>

2. ETag(서버에서만 캐시 제어 로직을 관리하고 클라이언트는 로직을 전혀 모른다)<br>
`if-None-Match` : 서버에서 임의의 고유한 버전 이름을 달아둬서 데이터가 변경되면 이름을 바꿔서 변경하는 매커니즘을 이용하여 체크하는 방법이다.<br>
HASH를 사용해서 같은 파일이면 같은 이름이 나오기에 변화 없음을 server에서 판단이가능하다.<br>
이름이 동일할 경우, if-None-Match가 실패하게 돼서 **304 Not Modified : 캐시로 redirection**를 보내며 전송할 데이터가 없기 때문에 HTTP Body의 내용이 존재하지 않고 캐시가 바뀌지 않아서 그냥 그대로 사용하면 된다는 것으로 확인하면 된다.<br>

--------

## 캐시와 조건부 요청 헤더

#### cache-control

- max-age : 유효기간을 초단위로 설정<br>
- no-cache : 데이터는 캐시해도 되지만 항상 원 서버(중간 캐시 서버가 아닌 그 뒤의 원서버)에 검증 헤더를 통한 로직을 사용해야한다.<br>
- no-store: 데이터가 민감한 정보가 있어서 지원하면 안 됨<br>

#### Expires

정확한 날짜로 지정해야해서 유연함이 떨어지기에 cache-control의 max-age를 사용하는 것이 사실 더 좋음.<br>


-----

## proxy cache

원 서버(original server)에서 여러 client가 접근할 때 매우 오래걸리는 경우가 발생이 가능하다.<br>
한국과 미국의 연결이라면..? 엄청 오래걸릴 것이다<br>

> proxy server : 중간의 서버를 하나 둬서 빠르게 응답을 받게끔 중간에 다리를 둔 서버를 의미한다.<br>

최초로 요청할 때는 프록시도 역시 원 서버에서 다운받아야해서 느리지만, 다음부터는 프록시 서버를 사용해서 빨라질 수 있다.<br>

- public : 모든 사용자가 공유해서 사용할 수 있는 정보
- private : 특정 사용자만을 위한 것
- s-maxage : proxy에만 적용되는 maxage
- age : origin 서버에서 응답후 proxy에서 머무는 시간


----

## 캐시 무효화

- 확실한 캐시 무효화 응답

계속 갱신이 되는 데이터의 경우 캐시를 사용해서는 안 된다.<br>
Cache-control에서 no-cache, no-store, must-revalidate, no-cache(http1.0하위호환)을 모두 적어줘야 확실하게 캐시 무효화를 처리할 수 있다.<br>

- no-chche, must-revalidate

둘다 모두 원서버에서 검증을 통해서 캐시를 사용하지 않음을 체크해야하는 것인데 no-cache는 프록시와 원 서버의 연결이 끊겼을 때 이전 캐시라도 보여주기 위해 200을 날리지만, must-revalidate의 경우 504 error를 내서 timeout을 발생시킨다는 것에서 차이점이 있다.<br>