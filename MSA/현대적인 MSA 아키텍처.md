# 현대적인 MSA 아키텍처

> **해당 내용은 Go로 구현하는 클라우드 네이티브 애플리케이션[미나 안드라오스 마틴 헬미크]를 기반으로 작성하였습니다.**

## 클라우드 네이티브 애플레이키션을 위한 설계 목표, 확장성

- <mark>확장성</mark> [Scalability]
> 사용자에게 효율적으로 서비스하고자 필요시 애플리케이션의 자원을 늘려 나가야 하는 것을 의미한다. 다른 한편 사용자가 없을 때 적절한 수준으로 자원을 다시 줄이는 것을 의미하기도 한다.<br>

- 종류
    1. 인스턴스(실제 물리적 메모를 점유해 실행되는 원본의 실체)를 사용하고 "인스턴스들"을 추가해(혹은 제거) 규모를 조정하는방법 : `scale out` = `수평적 확장`
    2. 인스턴스의 수를 조정하는 것이 아닌 "자원"을 조정하는 방법 : `scale in` = `수직적 확장`

    둘중 어떤 것이 선호될까?<br>
    1. 수평적 확장은 무제한의 선형적 확장성을 약속한다. 그러나 수직적 확장은 기존 서버에 추가할 수 있는 자원의 수가 무한대로 커질 수 없어서 자체로 한계를 가진다.<br>
    2. 수평적 확장은 저렴한 상용 하드웨어(클라우드 환경에서 더 작은 인스턴스) 사용이 가능해서 작은 인스턴스를 사용할 경우, 비용효율적이다. 다만, 큰 서버들은 흔히 비용이 더 기하급수적으로 늘어나게 될 것이다.

    모든 주요 클라우드 제공자들은 애플리케이션의 현재 자원 사용률 기준으로 자동으로 수평적 확장을 수행하는 능력을 제공하는데, 이 기능을 **오토스케일링(auto-scaling)** 이라고한다.<br>

- <mark>AutoScaling</mark>이 되려면?

    오토스케일링은 그냥 제공되지 않고 몇가지 고려해야할 사항들을 만족할 때 제공된다.<br>
    수평적 확장을 위한 조건을 생각해보면 어떻게보면 당연한 사항들이다.<br>

    1. Stateless : 인스턴스는 어떤 종류의 내부적인 상태 값을 가져서는 안 된다.<br>
        <U>scale-out을 한다는 가정하에 그 다음의 요청들은 해당 애플리케이션의 다른 인스턴스에 의해서 서비스될 수 있기에 어떠한 종류의 상태값에도 의존해서는 안 된다.</U><br>
    2. 쉬운배포 : 배포는 완전히 자동화 되어야한.<br>
        스케일아웃시, <U>자동으로 확장된 새로운 인스턴스들을 빠르게 배포할 수 있어야할</U>텐데어떤 종류의 수작업도 요구해서는 안 될 것이다.<br>
    3. 회복성 : 예고 없이 종료된 인스턴스(극한의 가용성을 보장하지 않기에 발생가능)에 대비해야한다.<br>
        클라우드 서비스는 극한의 가용성을 보장하지 않기에 어떠한 의도치 않은 장애로 인해 예기치 않은 중단과 갑작스러운 종료가 일어날지 모르기에 항상 대비해야 AutoScaling이 실패없이 진행될 것이다.<br>
    
    클라우드 제공자들은 위의 목표를 달성하기 위해서 대처를 지원하고자 자체 관리형 서비스([분산 파일 스토리지 기반의 고 확장성 데이터베이스 서비스](http://terms.tta.or.kr/dictionary/dictionaryView.do?subject=%EB%B6%84%EC%82%B0+%ED%8C%8C%EC%9D%BC+%EC%8B%9C%EC%8A%A4%ED%85%9C))를 제공할 것이다.<br>

    제공서비스를 사용하지 않고 구축하는 것은 매우 어려울 것이다. 이때, 실제 애플리에킹션 관련 확장성과 회복성을 갖춘 애플리케이션 구축을 위한 규칙들은 12요소 앱 방법론을 통해서 알 수 있다.

## 각기 다른 클라우드 서비스 모델

<img width="865" alt="image" src="https://user-images.githubusercontent.com/74058047/218271141-a9ffb24a-5395-40ae-bbdc-1374e315e39f.png">

### IaaS(InfraStructure as a Service)<br>
- 클라우드 서비스 제공자가 서버, 네트워크, 방화벽, 스토리지 장치들과 같은 클라우드 상의 인프라에 접근할 수 있게하는 모델이다.
- IaaS 제공자는 인프라 관리를 제공해 사용자는 유지 보수시의 번거로움과 비용에서 벗어난다.<br>
- application을 받치고 있는 영역의 모든 제어가 필요한 조직과 스타트업에 의해서 사용된다.<br>

### Paas(Platform as a Service)<br>
- Iaas의 바로 상위계층이다.<br>
- 애플리케이션 개발에 필요한 OS와 데이터베이스, 웹 계층(필요시), 프로그래밍 언어 실행 환경을 포함한다.<br>
- 애플리케이션 환경에 대한 업데이트와 패치를 클라우드 제공자가 담당하여 관련된 걱정을 하지 않아도 된다.<br>
- 예를 들어서, 닷넷 애플리케이션을 만든다고 가정하면, 필요한 윈도우 서버 OS와 IIS 웹 서버가 결합된 닷넷 환경을 제공할 것이다.<br>

### SaaS(Software as a Service)<br>
- 클라우드 서비스로 제공가능한 최상위 계층으로 웹을 통해 모든 소프트웨어 기능을 완전히 제공한다.<br>
- 웹 브라우저를 통해서 제공되며 일반적인 사용자들에 의해서 주로 사용된다.<br>
- 예를 들어서 넷플릭스를 클라우드에서 관리되는 하나의 복잡한 소프트웨어이기에 SaaS에 해당한다.<br>


## 12요소 앱

일반적인 애플리케이션 개발과 클라우드 환경에서의 개발의 차이는 크게 나지 않지만, 클라우드 환경을 목표로 할 때 몇 가지 고려해야할 공통적 특징이 있다.<br>

12요소 앱 방법론<br>
> 확장성과 회복성이 있는 클라우드 서비스를 만들어나가는 것에 대한 규칙들의 집합이다.<br> 자세한 설명은 http://12factor.net 에서 확인이 가능하다.

중요한 몇가지만 살펴본다.<br>
- Dependencies - 명시적으로 선언하고 의존성을 서로 "분리"시킨다.<br>
    클라우드 애플리케이션은 기존 시스템상 이미 존재하는 어떠한 필수 라이브러리나 외부 도구에도 결고 의존해서는 안 된다.<br>
    의존성은 명시되어야하는데 그 이유는 새로운 인스턴스 배포시 모든 의존성을 가져와서 확장시킬 수 있어야하기 때문이다.<br>만약 외부 시스템이나 C 라이브러리들에 필요한 기능을 의존했을 때, 애플리케이션이 완전해지려면 "도구들과 함께 배포해야하는데 도커와 같은 컨테이너를 사용한다."

- Config - 환경에 구성정보를 저장한다.<br>
    구성 정보는 배포가 달라짐에 따라 다양해질 수 있는 어떤 종류의 데이터로 환경변수를 통해서 애플리케이션으로 전달되어야한다.<br>

- Backing 서비스 - 의존 서비스를 추가되는 자원으로 다뤄야한다.<br>
    앱이 의존하는 서비스들이 구성 정보에 의해서 쉽게 교체될 수 있도록해야함을 의미하는데 예를 들어서 로컬에서는 mysql://root:root@localhost:test, 운영 환경에서는 aws의 endpoint를 환경 변수에 담아 받아서 쉽게 서비스가 교체되게끔한다.<br>

- Process - 비상태 기반 프로세스로 실행해야한다.<br>
    상태를 저장하면 안 된다. 따라서 단일 요청/트랜잭션(거래 정보를 처리하는 단위) 처리를 넘어 계속 유지해야하는 어떠한 종류의 데이터도 "외부의 지속성을 지원하는 서비스에 저장되어야한다."<br>
    예를 들어서 세션 데이터는 동일 사용자의 그 다음 요청들이 해당 애플리케이션의 동일한 인스턴스에 의해서 처리되어야하는 기대로 메모리에 보관되는데, 비상태 기반이 되도록 유지하거나 해당 세션의 상태 정보를 Redis나 Memcached와 같은 외부 데이터 저장소로 옮겨야한다.
- Disposability - 빠른 시작과 정상적인 종료 과정을 갖춰 견고함을 극대화해야한다.<br>
    클라우드는 무한한 가용성을 제공하지 않기에 갑작스러운 종료를 항상 염두에 두어야하는데 따라서 새로운 인스턴스를 배포할 수 있도록 빠른 시작시간을 가져야한다.<br>
    정상적인 종료도 마찬가지이다.<br>
    서버를 종료할 때는 OS는 일반적으로 애플리케이션이 인식해서 적절히 대응하도록 SIGTERM 신호를 보내 종료를 알린다.(Listen을 중지하고 요청을 끝내고 Exit처리를 진행)
- Logs - 로그를 이벤트의 연속된 흐름으로 다뤄야한다.<br>
    애플리케이션의 동작들을 디버깅과 모니터링하는 데 로그 데이터가 사용된다.<br> 하지만, 자신의 로그 데이터에 대한 경로 설정과 저장에 관련해서는 안 된다.<br>
    그러기 위해서는 로그의 흐름을 표준 출력 흐름에 작성하면 된다.<br>


## 마이크로서비스 아키텍처

소프트웨어의 진화는 기존 애플리케이션을 변경하지 않고 내버려둔다면 애플리케이션을 더 복잡하게 하며 유지 보수하기 어렵게 만든다."유지보수의 늪"에 빠지게 된다...ㅜㅜ!<br>

이런 소프트웨어 침식을 방지하기 위해 등장한 아키텍처 패러다임이 마이크로서비스이다.<br>

> 소프트웨어 시스템을 <U>독립적으로 격리된</U>(쪼개기!) 서비스들의 집합으로 분리하는 모델로 이것들은 분리된 프로세스들로 실행되며 네트워크 프로토콜로 통신한다.<br>

- 특징<br>
    - SOA와 다르게 MSA는 **단순함**에 집중한다.<br>
        <U>ESB(SOA를 구현할 수 있게 해주는 서비스 기반 구조)와 같은 복잡한 인프라 구성요소들은 반드시 피하고 SOAP 대신에 REST 같은 간단한 통신수단을 AMQ 메시징을 사용한다.</U>

    - 서로 다른 서비스들은 각자 별도의 기술 조합으로 만들어질 수 있는데 그 때마다 구성하는 스택을 다르게 선택하는 것이 최선이 될 수 있다.<br>
    이렇게 서비스의 기능을 **EnCapsulating** 하는 것은 개발시 최적의 도구를 선택할 수 있게한다.<br>

    - 유연한 개발, 배포, 운영이 가능하게끔 한다.<br>
        개발시, 하나의 큰 덩어리로 된 애플리케이션보다 개별 서비스 배포가 더 쉽다.<br>
        다만, <U>서로 다른 서비스들이 각각 다른 기술들을 사용할 때 배포가 더 어려워지는데 이를 해결하기 위해서 Docker나 RKT같은 최신 컨테이너 런타임으로 제공하는 서비스를 사용한다</U>.<br>
        

## REST 웹 서비스와 비동기식 메시징

### 동기식 요청/응답 패턴의 강한 결합성 이슈<br>
HTTP Protocol에서 동기식 요청/응답 통 통신 방식의 클라이언트/서버 모델은 일반적으로 구현되며 유지보수에 장점이있다.<br>

그러나. 많은 서비스에 걸쳐있는 복잡한 프로세스들로 시스템을 구현 중이라면? 한계에 부딪힐 수 있다.<br>

예를 들어서 사용자의 데이터베이스를 관리하는 사용자 서비스가 있을 때 사용자 서비스는 사용자와 관련된 예약 서비스, 추천 서비스, 결제관리 서비스 등등 많은 서비스가 얽혀있다면 "새로운 사용자 등록(new event)"가 오면 다른 서비스에게 인식시켜줘야한다.<br>
서로 "강한 결합성"이 있다.<br>

### 비동기식 발행/구독 패턴<br>
이러한 issue를 해결하기 위해서 대안적인 통신패턴은 <mark>**발행/구독**</mark>패턴이다.<br>
evnet를 발행하고 이를 관련된 서비스가 구독하여 메시지를 받아들이고 이들을 해당 구독자들에게 특정 경로로 전달한다.<br>
이때, 특별한 인프라 구성요소인 메시지 브로커의 사용을 요구한다. 구성 요소는 발행된 메시지를 받아들이고 이들을 해당 구독자에게 특정 경로로 전달한다.<br>
서로 간의 결합을 분리하는 아주 좋은 방법이 된다.<br>
발행시 이들이 어디로 갈지 생각을 하지 않아도 되며, 언제 다른 서비스가 해당 이벤트를 구독할지에 대해서 고민할 필요가 없다.<br> 심지어 해당 이벤트들이 어디서 왔는지도 모른다.<br>

## 세상에는 공짜 점심이 없다!

유여성과 확장성은 복잡성이 추가되는 대가를 지불해야하며 다수의 서버에 걸친 단일 프로세스의 디버깅이 어렵게 된다. 결국 해당 트레이드오프를 받아들일 수 있을지 여부는 사례 별 기준으로 평가 되어야한다.<br>

