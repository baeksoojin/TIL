# Graphql이란?

> github의 graphql [설명서](https://graphql-kr.github.io/learn/)를 보면, graphql이란 API를 위한 쿼리 언어이며 타임 시스템을 사용하여 쿼리를 실행하는 서버사이드 런타임으로 정의하고 있다.

## 특징

- 특정 스토리지 엔진과 특정 데이터베이스에 관계되어 있지 않다.
- 기존 코드와 데이터에 의해서 대체된다.
- 쿼리와 뮤테이션에 의해서 데이터를 주고 받게 된다.

---


## 쿼리 & 뮤테이션

쿼리와 뮤테이션 둘다 api를 위한 쿼리 언어를 사용해, request를 보내고 response를 요청하는 것이다. 두개의 기능이 동일한 것인가? 그렇지 않고 우리는 쿼리를 사용할 때는 GET 을 하는 경우 주로 사용하고 mutation을 사용하면 수정을 위한 action을 처리하기 위해서 사용한다고 생각하면 된다.<br>
위의 내용은 명시적으로 데이터 가져오기는 query를 사용하고 변경이 발생하는 작업이라면 mutation을 사용한다는 규칙에 의한 것이다.<br>

### 쿼리(Query)

> graphql에서의 쿼리는 데이터 가져오기에 대해 초점을 맞춘다.


```
{
    hero{
        name
    }
}
```
graphql에서 객체에 대한 "특정 필드 요청"은 매우 간단하다고 나와있다.<br>
위에서 볼 수 있듯이 hero의 name 속성을 얻고 싶을 때의 쿼리는 매우 간단하다.<br>
쿼리와 결과는 정확히 동일한 형태인 것을 볼 수 있을 것이다.<br>
결과는 
```
{
    "data" : {
        "hero": {
            "name" : "R2-D2"
        }
    }
}
```
위와 같다.<br>

query와 result가 정확히 동일한 형태인 것이 핵심이라고 나와있다. 이것이 정확히 어떤 것을 의미하는 것일까?<br>

서버에서 클라이언트가 요청한 것을 정확히 알고 그것만 반환한다는 것을 의미한다.<br>

- 특징

    1. 다른 인자를 사용해 같은 필드를 직접 쿼리할 수 없기에 별칭을 사용
    2. fragment를 사용해 공통된 필드의 반복을 최소한으로 줄여서 사용
    3. `query` keyword와 이름을 모두 생략할 수는 있지만, 실제 개발의 단계에서는 `mutation`과의 구분을 위해 작성하는 것을 권장

### 뮤테이션(Mutation) 

우선 간단히 제공되는 예시를 가져와봤다.!<br>
```
query HeroForEpisode($ep: Episode!) {
  hero(episode: $ep) {
    name
    ... on Droid {
      primaryFunction
    }
    ... on Human {
      height
    }
  }
}
```
해당 코드는 뮤테이션으로 쿼리를 진행한 간단한 예제이다.<br>
{"ep": "JEDI"} 라는 value가 사용되고 이 value에 의해서 hero가 결정되고 이에 따라서 프래그먼트의 수행이 primaryFunction 인지 height인지 결정해 데이터를 요청하는 것이다.<br>
```
{
  "data": {
    "hero": {
      "name": "R2-D2",
      "primaryFunction": "Astromech"
    }
  }
}
```
hero는 ep가 JEDI였기에 Droid를 hero가 반환하고 primaryFunction의 프래그먼트가 적용됨을 알 수 있다.<br>


> graphql에서의 mutation은 서버 측 데이터를 `수정` 하기 위한 역할로 사용된다.

- 특징
    1. 다중필드에서의 query와의 차이점 : 뮤테이션 필드는 하나씩 차례대로 실행된다.(순서가 보장된다)
    2. 인터페이스나 유니언 타입을 반환하는 필드를 쿼리할 때, 인라인 프래그먼트를 사용해서 필드의 반환 타입에 따른 다른 프로그래먼트를 수행
    3. meta 필드를 사용해서 `__typename`를 사용해 리턴될 타입을 모르는 상황에서도 뮤테이션을 적용 가능


---

## Rest API와의 차이점?

1. 연관된 객체와 필드를 탐색할 수 있기 때문에 오는 차이점

    REST 구조는 여러번 요청을 수행해야하지만, graphql은 여러번 요청을 하지 않아도 연관된 객체와 필드를 탐색할 수 있기에 클라이언트는 한번의 요청을 수행해도 많은 데이터를 가져올 수 있게된다.

2. 요청을 하기 위한 인자에서오는 api fetch 횟수의 차이점

    REST의 경우, 쿼리 파라미터에 URL 세그먼트와 같은 단일 인자들을 전달할 수 있었다. 그러나 graphql은 단일인자 뿐만 아니라 모든 필드와 중첩된 객체가 인자를 가질 수 있기에 여러번의 API fetch(가져오기 action 관련)를 완벽하게 대체가 가능하다.


