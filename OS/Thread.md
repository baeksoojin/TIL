## Thread

- basic unit of CPU
    
    ThreadID, program counter, register set, stack space를 가짐
    
- peer thread끼리 서로 같은 자원을 공유하고 있음
- heavyweight process : 더이상 쪼개지지 않는 task or process로 one thread를 가지는 프로세스

**LAYER 측면에서 봤을 때**

- user level thread : user 관련 관리 스레드로(종료나 시작 등)을 system library에서 미리 제공 (a set of library안에 thread생성 기능이 이미 만들어져있음) : 커널에게 자원을 요청하거나 할 일이 없어서 쉽게 빠르게 부담없이 동작이 가능
- kernel level thread : CPU에게 던져지는 일감에 해당되기에 하나를 만들때마다 resource가 필요. 몇개이상 만들면 시스템의 부하가 발생가능. 최적의 thread의 개수를 결정짓는 것이 필요함.
- Hybrid : kernel level thread와 user level thread를 두개 사용. 서로의 개수가 동일하고 CPU는 kernel level thread만 신경쓰게 됨.

---

## Multiple Thread

**장점**

서로 datam pc를 공유하고 사용하기에 context switcing과정을 통해서 새로운 메모리 영역을 할당하는 과정이 매번 필요하지 않다.

Not Independent of one anohter하기 때문에 , 하나의 thread가 block되더라도 다른 thread가 처리해주는 장점이 존재한다.

---

## Multithreading Models

- Many-to-One

하나의 Kernel level thread가 존재. user thread가 경쟁해서 잡아야함.

- One-to-One



일대일로 mapping되어, 경합하지 않아도 된다.

다만, kernel level thread는 계속 만들 수 없음(자원적인 부분)

- Many-to-Many

kernel thread를 최적 개수로 한정시키고 그것을 user thread끼리 공유해서 사용

조금 더 나아졌지만, 계속해서 경합이 붙는 것은 마찬가지.

그렇다면, 중요한 일처리를 계속해서 하지 못할 수 있게된다.

- Two-level Model

중요한 부분은 하나의 kernel로 할당해서 처리.


---

## Threading Issues

- fork(), exec()
- thread cancellaation
- signal handling
- thread pools
- thread specific data
- schduler activations(User level과 Kernel level thread를 connunication해서 적정수준의 thread를 만들어주는 방법)

- fork(), exec()에 따른 복사범위
    1. fork() → exec() : fork 호출한 thead만 복사본을 만든다
    2. fork()만 사용 : 전체 process를 복사한다.

- thread cancellation

| 구분 | 특징 |
| --- | --- |
| Asynchronous cancellation | 하던일을 바로 종료 |
| Deferred cancellation(cancellation point에서만 cancel) | 바로 끝내지 않고 cancel point를 만날때까지 지연 |

**Issue** : 즉시종료(기다리지 않고 종료) Asynchronous cancellation : 하던일을 그냥 바로 종료하면 저장하지 못하고 종료하여 문제가 될 수 있다. thread가 공유데이터의 값을 변경하고 있는와중에(critical section) async cancell이 되면 값이 꼬여버림.

- signal handling

    signal이 들어오면 handling하는 방법에 대해서 알아보자!

    1. generated by particular event : 발생시킨애한테 처리하라고 하는 방식
    2. delivered : 다른 thread로 전달
    3. signal 처리 전담반을 생성 : 여러개가 돌려가며 처리
    4. 하나의 thread로 signal 처리 역할을 부여(다른일은 하지 않음)

- thread pool

    항상 자원을 고려해, 적정 개수를 만들어야한다.

    thread를 미리 만들어놓고 운용하는 방식이다.

    why? 필요시에 만드는 것보다 빠르다, 시스템상으로 적정 개수의 thread를 유지할 수 있다.

- thread specific data

    원래는 하나의 process의 thread들은 데이터를 공유하고 있는데, own copy of data를 따로 가지게 한 thread를 만들 수 있다.

    transaction이 전부 다르기때문에 각각의 transaction마다 each thread로 하여 다른 데이터를 처리하도록한다.

- schedular activations

    일감에 따라서 thread를 줄이거나 늘리거나 해야함.

    일감을 어떻게 많은지 적은지 구분하나? → **UPCALL** :  user level thread를 일단 뿌려놓고 kernel에게 어디에서 thread가 많이필요할지 알 수 있게함

-----

## Thread type

- Pthreads

    thread library의 이름으로 POSIX api에서 제공되는 library중 하나

    POSIX super set > Pthreads subset 

    동기화, 종료 등의 thread관련 library

- Windows XP Thread

    one(user)-to-one(user) : one-to-one의 단점을 가져감(kernel level을 user level에서 사용하고 싶은만큼 무한대로 늘릴 수 없다는 단점)

    Thread Context : thread id, register set, separate user and kernel stacks, datat storage area

- Linux Thread

    thread를 task라고 주로 부른다.

    fork()대신, clone()이 있다. → to share thre address

- JAVA Threads

    threads are managed by the JVM

- Java Thread States

  <img width="1075" alt="image" src="https://user-images.githubusercontent.com/74058047/231045833-a73d67c5-caa1-4a01-974d-5adce631ed45.png">
